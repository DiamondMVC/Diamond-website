COPYRIGHT=Copyright © 2017 Diamond MVC

HOME_MENU=Home
DOWNLOAD_MENU=Download
DOCS_MENU=Documentation
TUTORIALS_MENU=Tutorials
COMMUNITY_MENU=Community
CONTRIBUTING_MENU=Contribute
SUPPORT_MENU=Support Us

HOME_TITLE=Home

FOCUS_TITLE:
A full-stack native MVC / Template Framework written in
<a href=https://dlang.org/>D</a>, based on <a href=http://vibed.org/>vibe.d</a>
;

FOCUS_CATCHPHRASE=Innovation, performance and elegance are Diamond's key elements.

GET_DIAMOND=Get Diamond 2.5.2
SUPPORT_US=Support Us

GET_STARTED=Get Started With Diamond
GET_STARTED_DOWNLOAD=Download
GET_STARTED_LEARN=Learn
GET_STARTED_DEPLOY=Deploy
GET_STARTED_CONTRIBUTE=Contribute

REASONS_TO_USE_DIAMOND=10 Reasons Why You Should Use Diamond

REASONS_TO_USE_DIAMOND_0=High performance, low CPU-usage
REASONS_TO_USE_DIAMOND_1=Innovative
REASONS_TO_USE_DIAMOND_2=Native without complexity
REASONS_TO_USE_DIAMOND_3=User-friendly
REASONS_TO_USE_DIAMOND_4=Focus on developing, rather than getting started
REASONS_TO_USE_DIAMOND_5=Easy learning curve
REASONS_TO_USE_DIAMOND_6=Expressive templates without annoyance
REASONS_TO_USE_DIAMOND_7=Based on modern concepts
REASONS_TO_USE_DIAMOND_8=Written in D
REASONS_TO_USE_DIAMOND_9=Uses vibe.d for its backend

FEATURE_OVERVIEW=Feature Overview

FEATURES_GENERAL_FEATURES=General Features
FEATURES_DATA_STORAGE=Data & Storage
FEATURES_VIEWS_FRONTEND=Views & Frontend
FEATURES_CONTROLLERS=Controllers
FEATURES_MORE=More

FEATURES_LOW_MEMORY=<a href="#feature-display" onclick="Diamond.Core.getFeature('low-memory');">Low Memory & CPU Consumption</a>
FEATURES_ORM=<a href="#feature-display" onclick="Diamond.Core.getFeature('orm');">ORM</a>
FEATURES_CTFE_PARSING=<a href="#feature-display" onclick="Diamond.Core.getFeature('ctfe-parsing');">Compile-time Parsing</a>
FEATURES_AUTO_MAPPING=<a href="#feature-display" onclick="Diamond.Core.getFeature('auto-mapping');">Auto-mapping</a>
FEATURES_AUTHENTICATION=<a href="#feature-display" onclick="Diamond.Core.getFeature('authentication');">Authentication</a>

FEATURES_MVC_HMVC=<a href="#feature-display" onclick="Diamond.Core.getFeature('mvc-hmvc');">MVC & HMVC</a>
FEATURES_MYSQL_ORM=<a href="#feature-display" onclick="Diamond.Core.getFeature('mysql-orm');">MySql ORM</a>
FEATURES_PARTIAL_VIEWS=<a href="#feature-display" onclick="Diamond.Core.getFeature('partial-views');">Partial Views</a>
FEATURES_VIEW_INTEGRATION=<a href="#feature-display" onclick="Diamond.Core.getFeature('view-integration');">View-integration</a>
FEATURES_CSRF_PROTECTION=<a href="#feature-display" onclick="Diamond.Core.getFeature('csrf-protection');">CSRF Protection</a>

FEATURES_RESTFUL=<a href="#feature-display" onclick="Diamond.Core.getFeature('restful');">RESTful</a>
FEATURES_CACHING=<a href="#feature-display" onclick="Diamond.Core.getFeature('caching');">Caching</a>
FEATURES_LAYOUTS=<a href="#feature-display" onclick="Diamond.Core.getFeature('layouts');">Layouts</a>
FEATURES_MANDATORY_ACTIONS=<a href="#feature-display" onclick="Diamond.Core.getFeature('mandatory-actions');">Mandatory Actions</a>
FEATURES_CRYPTOGRAPHY=<a href="#feature-display" onclick="Diamond.Core.getFeature('cryptography');">Cryptography</a>

FEATURES_ADVANCED_ROUTING=<a href="#feature-display" onclick="Diamond.Core.getFeature('advanced-routing');">Advanced Routing</a>
FEATURES_MONGO=<a href="#feature-display" onclick="Diamond.Core.getFeature('mongo');">Mongo</a>
FEATURES_FAST_PERFORMANT_RENDERING=<a href="#feature-display" onclick="Diamond.Core.getFeature('fast-performant-rendering');">Fast & Performant Rendering</a>
FEATURES_VERSION_CONTROL=<a href="#feature-display" onclick="Diamond.Core.getFeature('version-control');">Version-control</a>
FEATURES_JSON_BSON=<a href="#feature-display" onclick="Diamond.Core.getFeature('json-bson');">JSON/BSON</a>

FEATURES_ACL=<a href="#feature-display" onclick="Diamond.Core.getFeature('acl');">ACL</a>
FEATURES_REDIS=<a href="#feature-display" onclick="Diamond.Core.getFeature('redis');">Redis</a>
FEATURES_VIEWS_DYNAMIC=<a href="#feature-display" onclick="Diamond.Core.getFeature('dynamic');">Dynamic</a>
FEATURES_ASYNC=<a href="#feature-display" onclick="Diamond.Core.getFeature('async');">Asynchronous</a>

FEATURES_CROSS_PLATFORM=<a href="#feature-display" onclick="Diamond.Core.getFeature('cross-platform');">Cross-platform</a>
FEATURES_REQUEST_CONTEXT=<a href="#feature-display" onclick="Diamond.Core.getFeature('request-context');">Request-context</a>
FEATURES_D_CODE_EXECUTION=<a href="#feature-display" onclick="Diamond.Core.getFeature('d-code-execution');">Any D Code Can Be Executed</a>
FEATURES_FIBERS_TASKS=<a href="#feature-display" onclick="Diamond.Core.getFeature('fibers-tasks');">Fibers/Tasks</a>

FEATURES_WEBSITE_WEBAPI=<a href="#feature-display" onclick="Diamond.Core.getFeature('website-webapi');">Website/Webapi Support</a>
FEATURES_COOKIES=<a href="#feature-display" onclick="Diamond.Core.getFeature('cookies');">Cookies</a>
FEATURES_SECTIONS=<a href="#feature-display" onclick="Diamond.Core.getFeature('sections');">Sections</a>
FEATURES_SHARDING=<a href="#feature-display" onclick="Diamond.Core.getFeature('sharding');">Sharding</a>

FEATURES_I18N=<a href="#feature-display" onclick="Diamond.Core.getFeature('i18n');">i18n</a>
FEATURES_SESSIONS=<a href="#feature-display" onclick="Diamond.Core.getFeature('sessions');">Sessions</a>
FEATURES_FLASH_MESSAGES=<a href="#feature-display" onclick="Diamond.Core.getFeature('flash-messages');">Flash-messages</a>
FEATURES_NETWORK_SECURITY=<a href="#feature-display" onclick="Diamond.Core.getFeature('network-security');">Network Security & Restrictions</a>

FEATURES_WEBSOCKETS=<a href="#feature-display" onclick="Diamond.Core.getFeature('websockets');">Websockets</a>
FEATURES_TRANSACTIONS=<a href="#feature-display" onclick="Diamond.Core.getFeature('transactions');">Transactions</a>
FEATURES_UNITTESTING=<a href="#feature-display" onclick="Diamond.Core.getFeature('unittesting');">Unittesting</a>

FEATURES_LOGGING=<a href="#feature-display" onclick="Diamond.Core.getFeature('logging');">Logging</a>


FEATURES_LOW_MEMORY_TITLE=Low Memory & CPU Consumption

FEATURES_ORM_TITLE=ORM
FEATURES_CTFE_PARSING_TITLE=Compile-time Parsing
FEATURES_AUTO_MAPPING_TITLE=Auto-mapping
FEATURES_AUTHENTICATION_TITLE=Authentication

FEATURES_MVC_HMVC_TITLE=MVC & HMVC
FEATURES_MYSQL_ORM_TITLE=MySql ORM
FEATURES_PARTIAL_VIEWS_TITLE=Partial Views
FEATURES_VIEW_INTEGRATION_TITLE=View-integration
FEATURES_CSRF_PROTECTION_TITLE=CSRF Protection

FEATURES_RESTFUL_TITLE=RESTful
FEATURES_CACHING_TITLE=Caching
FEATURES_LAYOUTS_TITLE=Layouts
FEATURES_MANDATORY_ACTIONS_TITLE=Mandatory Actions
FEATURES_CRYPTOGRAPHY_TITLE=Cryptography

FEATURES_ADVANCED_ROUTING_TITLE=Advanced Routing
FEATURES_MONGO_TITLE=Mongo
FEATURES_FAST_PERFORMANT_RENDERING_TITLE=Fast & Performant Rendering
FEATURES_VERSION_CONTROL_TITLE=Version-control
FEATURES_JSON_BSON_TITLE=JSON/BSON

FEATURES_ACL_TITLE=ACL (Access-control-list)
FEATURES_REDIS_TITLE=Redis
FEATURES_VIEWS_DYNAMIC_TITLE=Dynamic
FEATURES_ASYNC_TITLE=Asynchronous

FEATURES_CROSS_PLATFORM_TITLE=Cross-platform
FEATURES_REQUEST_CONTEXT_TITLE=Request-context
FEATURES_D_CODE_EXECUTION_TITLE=Any D Code Can Be Executed
FEATURES_FIBERS_TASKS_TITLE=Fibers/Tasks

FEATURES_WEBSITE_WEBAPI_TITLE=Website/Webapi Support
FEATURES_COOKIES_TITLE=Cookies
FEATURES_SECTIONS_TITLE=Sections
FEATURES_SHARDING_TITLE=Sharding

FEATURES_I18N_TITLE=i18n
FEATURES_SESSIONS_TITLE=Sessions
FEATURES_FLASH_MESSAGES_TITLE=Flash-messages
FEATURES_NETWORK_SECURITY_TITLE=Network Security & Restrictions

FEATURES_WEBSOCKETS_TITLE=Websockets
FEATURES_TRANSACTIONS_TITLE=Transactions
FEATURES_UNITTESTING_TITLE=Unittesting

FEATURES_LOGGING_TITLE=Logging

FEATURES_LOW_MEMORY_CONTENT:
Diamond uses vibe.d as backend for processing requests, which currently processes more requests than any other frameworks.
<br><br>
At the same time Diamond is written in D and utilizes D’s compile-time facilities and
thus keeps as little overhead at run-time as possible.
<br><br>
The memory consumption is low, because Diamond doesn’t store much more data in memory than requested,
except for minimal session/cookie/request data.
<br><br>
The CPU consumption is kept to a minimum,
because of how vibe.d works with its asynchronous fiber model.
;

FEATURES_MVC_HMVC_CONTENT:
Diamond has a full integrated Model-view-controller implementation,
which is based on a similar design to ASP.NET.
<br><br>
Implementing views, controllers and models is a straightforward concept in Diamond and
made to feel as natural as possible.
<br>
<img src="/public/diamond/images/mvc.jpg">
;

FEATURES_RESTFUL_CONTENT:
Diamond can be RESTful if necessary.
<br>
REST integration becomes very powerful & secure with the combination of ACL.

<pre>
@HttpAction(HttpGet, "/product/{uint:productId}/") Status getProduct()
{
    auto productId = get!uint("productId");
    auto product = getProductFromDatabase(productId);

    return json(product);
}
</pre>

<pre>
@HttpAction(HttpPut, "/product/{uint:productId}/") Status insertOrUpdateProduct()
{
    auto productId = get!uint("productId"); // If the id is 0 then we'll insert, else we'll update.

    insertProductToDatabase(productId, view.client.json); // Normally you'll want to deserialize the json

    return jsonString(q{{
        "success": true
    }});
}
</pre>

<pre>
@HttpAction(HttpDelete, "/product/{uint:productId}/") Status deleteProduct()
{
    auto productId = get!uint("productId");

    deleteProductFromDatabase(productId);

    return jsonString(q{{
        "success": true
    }});
}
</pre>
;

FEATURES_ADVANCED_ROUTING_CONTENT:
Diamond allows for advanced routing with controller actions, which can be type-secure.

<pre>
@HttpAction(HttpGet, "/<>/{uint:userId}/groups/{string:groupName}/") getUserGroup()
{
    auto userId = get!uint("userId");
    auto groupName = get!string("groupName");

    auto userGroup = getUserGroupFromDatabase(userId, groupName);

    return json(userGroup);
}
</pre>
;

FEATURES_ACL_CONTENT:
Diamond has a full-fletched build-in ACL implementation.
<br>
It allows for custom creation of roles and permission control of resources.
<br>ACL can be combined with the build-in authentication too.

<pre>
auto administrators = addRole("administrators");

auto owner = addRole("owner", administrators);
auto superUser = addRole("super-user", administrators);
</pre>

<pre>
auto guest = addRole("guest")
  .addPermission("/", true, false, false, false) // Guests can view home page
  .addPermission("/user", true, true, false, false) // Guests can view user pages, as well register (POST)
  .addPermission("/login", true, true, false, false) // Guests can view login page, as well login (POST)
  .addPermission("/logout", false, false, false, false); // Guests cannot logout, because they're not logged in

auto user = addRole("user")
  .addPermission("/", true, false, false, false) // Users can view home page
  .addPermission("/user", true, false, true, false) // Users can view user pages, as well update user information (PUT)
  .addPermission("/login", false, false, false, false) // Users cannot view login page or login
  .addPermission("/logout", false, true, false, false); // Users can logout (POST)
</pre>
;

FEATURES_CROSS_PLATFORM_CONTENT:
Diamond supports all platforms that both vibe.d & D supports, which includes Windows, Linux, macOS/OSX and more.
<br><br>
<img src="https://img.shields.io/badge/os-windows%20%7C%20linux%20%7C%20macos-ff69b4.svg" alt="OS">
;

FEATURES_WEBSITE_WEBAPI_CONTENT=Diamond has support for both writing websites and/or webapis.

FEATURES_I18N_CONTENT:
i18n (Internationalization) can be used to localize Diamond application for different languages and cultures.

<pre>
import diamond.data.i18n; // Or just diamond.data

auto message = getMessage(client, "someMessage"); // Gets message from client ...
auto specificMessage = getMessage("en_us", "someMessage"); // Gets message from a specific language ...
</pre>

<pre>
&lt;p&gt;@=i18n.getMessage(client, "someMessage");&lt;/p&gt;
&lt;p&gt;@=i18n.getMessage("en_us", "someMessage");&lt;/p&gt;
</pre>

<pre>
@* Will show the flag depending on the client's language. *
&lt;img src="@../public/images/flags/@=client.language;.png"&gt;
</pre>
;

FEATURES_WEBSOCKETS_CONTENT:
Diamond has build-in support for websockets with an easy-to-use API.
<br><br>
It works by implementing a websocket service that you can use to handle the websockets.
<br><br>
Each websocket also comes with a context that can be used to store data, similar to request-contexts.

<pre>
import diamond.http.websockets;
import diamond.core.io;

private final class TestWebSocketService : WebSocketService
{
  final:
  this()
  {
    super("/ws");
  }

  override void onConnect(WebSocket socket)
  {
    socket.add("id", "mySocket");

    print("'%s' connected ...", socket.get!string("id"));
  }

  override void onMessage(WebSocket socket)
  {
    print("'%s' received a message ...", socket.get!string("id"));

    auto message = socket.readText();

    string message2;
    if (!socket.readTextNext(message2)) return;

    uint uintValue;
    if (!socket.readNext!uint(uintValue)) return;

    bool boolValue;
    if (!socket.readNext!bool(boolValue)) return;

    print("values: ['%s', '%s', %d, %s]", message, message2, uintValue, boolValue);

    socket.send("Hello World!");
    socket.send(12345);
  }

  override void onClose(WebSocket socket)
  {
    print("'%s' has closed ...", socket.get!string("id"));
  }
}
</pre>

<pre>
addWebSocketService(new TestWebSocketService);
</pre>

<pre>
var socket = new WebSocket("ws://127.0.0.1/ws");

socket.onopen = function (event) {
  console.info("Open ...");

  for (var i = 0; i < 3; i++) {
    console.info("Begin send ...");
    socket.send("Hello Message1!");
    socket.send("Hello Message2!");
    socket.send(12345);
    socket.send(true);
  }
};

socket.onmessage = function (event) {
  console.info("Received:");
  console.info(event.data);
};

socket.onclose = function(event) {
  console.info("Closed ...");
};
</pre>
;

FEATURES_ORM_CONTENT:
Diamond has a build-in ORM which can be used to map customized data ex. other database-engines.
;

FEATURES_MYSQL_ORM_CONTENT:
By default Diamond has a build-in ORM for Mysql. It’s very powerful since it’s based on the native mysql library.

<pre>
module models.mymodel;

import diamond.database;

class MyModel : MySql.MySqlModel!"mymodel_table"
{
  public:
  @DbId ulong id;
  string name;

  this() { super(); }
}
</pre>

<pre>
import diamond.database;
import models;

static const sql = "SELECT * FROM `@table` WHERE `id` = @id";

auto params = getParams();
params["id"] = cast(ulong)1;

auto model = MySql.readSingle!MyModel(sql, params);
</pre>
;

FEATURES_CACHING_CONTENT:
Diamond implements a lot of caching techniques behind the scenes. It also allows for custom caching of ex. expensive views.
<br>
<img src="/public/diamond/images/cache.jpg">
;

FEATURES_MONGO_CONTENT:
Diamond has a full integration to Mongo through vibe.d
<br>
Source: <a href="http://vibed.org/docs#mongo">http://vibed.org/docs#mongo</a>
<pre>
import vibe.d;

MongoClient client;

void test()
{
	auto coll = client.getCollection("test.collection");
	foreach (doc; coll.find(["name": "Peter"]))
		logInfo("Found entry: %s", doc.toJson());
}

shared static this()
{
	client = connectMongoDB("127.0.0.1");
}
</pre>
;

FEATURES_REDIS_CONTENT:
Diamond has a full integration to Redis through vibe.d
<br>
See: <a href="http://vibed.org/docs#redis">http://vibed.org/docs#redis</a>
;

FEATURES_REQUEST_CONTEXT_CONTENT:
Diamond supports request contexts which allows for each request to have any type of data carried with them anywhere in the application.
<pre>
client.addContext("someString", "Hello World!");

...

auto someString = client.getContext!string("someString", "someString wasn't found!");
</pre>
;

FEATURES_COOKIES_CONTENT:
Diamond has a very user-friendly cookie API directly bound to the request’s http client.
<pre>
client.cookies.create("myCookie", "Hello Cookie!", 60);

...

auto myCookie = client.cookies.get("myCookie");
</pre>
;

FEATURES_SESSIONS_CONTENT:
Diamond supports sessions, which can share data and cached views between multiple requests from the same user/browser.
<pre>
client.session.setValue("mySesionValue", "Hello Session!");

...

auto mySessionValue = client.session.getValue("mySessionValue");
</pre>
;

FEATURES_TRANSACTIONS_CONTENT:
Transactions allows for transactional memory management, as well transactional database integration.
<br><br>
It’s useful to perform secure data transactions where invalid/incomplete data cannot be afforded.
<pre style="max-height: 400px;">
auto bob = new Snapshot!BankAccount(BankAccount("Bob", 200));
auto sally = new Snapshot!BankAccount(BankAccount("Sally", 0));

auto transaction = new Transaction!BankTransfer;
transaction.commit = (transfer)
{
    bob = BankAccount(bob.name, bob.money - transfer.money);
    sally = BankAccount(sally.name, sally.money + transfer.money);

    UpdateBankAccount(bob);
    UpdateBankAccount(sally);
};
transaction.success = (transfer)
{
    import diamond.core.io;

    print("Successfully transferred $%d from %s to %s", transfer.money, transfer.from, transfer.to);
    print("Bob's money: %d", bob.money);
    print("Sally's money: %d", sally.money);
};
transaction.failure = (transfer, error, retries)
{
    bob.prev(); // Goes back to the previous state of Bob's bank account
    sally.prev(); // Goes back to the previous state of Sally's bank account

    return false; // We don't want to retry ...
};

auto transfer = new Snapshot!BankTransfer(BankTransfer("Bob", "Sally", 100));
transaction(transfer);
</pre>
;

FEATURES_CTFE_PARSING_CONTENT:
Views are parsed at compile-time and gets compiled into D classes that are executed at run-time.
<br>
This makes them very powerful, because they don’t have to be parsed on each requests, giving them minimal processing only.
;

FEATURES_PARTIAL_VIEWS_CONTENT:
Partial views can easily be implemented by creating normal views and simply calling the render functions from a view to render other views.
<pre>
@* In a view *

@:render("myPartialView");

...

@:render("myPartialView", "someSection");

...

@render!"myPartialView"(new MyPartialViewModel("something something"));
</pre>
;

FEATURES_LAYOUTS_CONTENT:
Views can use layout views, which allows for advanced layout techniques and view mixins.
<br><br>
<b>layout.dd</b>
<pre>
@&lt;doctype>
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;@&lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  @&lt;view&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<br>
<b>home.dd</b>
<pre>
@[
  layout:
    layout
---
  route:
    home
---
  placeHolders:
    [
      "title": "Home"
    ]
]

The time is: &lt;b&gt;@=Clock.currTime();&lt;/b&gt;
</pre>
;

FEATURES_FAST_PERFORMANT_RENDERING_CONTENT=Views are rendered fast, because most of their rendering is done at compile-time.

FEATURES_VIEWS_DYNAMIC_CONTENT:
All views are dynamic and thus can render dynamic data.
<pre>
&lt;ul&gt;
@:foreach (item; model.items) {
    &lt;li&gt;
        &lt;b&gt;@=item.name;&lt;/b&gt;
    &lt;/li&gt;
}
&lt;/ul&gt;
</pre>
;

FEATURES_D_CODE_EXECUTION_CONTENT:
Views allows for any type of D code to be executed with no limits.
<br>
This includes class generation, templates, functions, and expressions directly in the view.
<br><br>
It’s very useful to generate powerful and fast dynamic data.
<br><br>
Since D is natively compiled, so will the code execution for the view be and thus execution times for the code is very fast (On pair with C/C++.)
<pre>
@:void b(T)(T item) {
    &lt;strong&gt;@=item;&lt;/strong&gt;
}
@:b("Bold this");
</pre>
;

FEATURES_SECTIONS_CONTENT:
Diamond allows views to be split up in multiple sections, which can allow for views to only be partially rendered.
<br><br>
This is a unique feature to Diamond that isn’t seen in many other frameworks, and especially not as such a clean and innovative implementation.
<br><br>
It’s a great help to ex. responsive designs, dynamic ajax data etc.
<br><br>
In fact this content is rendered using sections.
<br><br>
<b>view1:</b>
<pre>
@!phone:
&lt;div class="phone"&gt;
    &lt;p&gt;Hello Phone!&lt;/p&gt;
&lt;/div&gt;

@!desktop:
&lt;div class="desktop"&gt;
    &lt;p&gt;Hello Desktop!&lt;/p&gt;
&lt;/div&gt;
</pre>
<br>
<b>view2:</b>
<pre>
@:render("view1", "phone"); // Will render view1 with the phone section
@:render("view1", "desktop"); // Will render view1 with the desktop section
</pre>
;

FEATURES_FLASH_MESSAGES_CONTENT:
Flash-messages are useful to create notification messages in a website.
<pre>
@:flashMessage("message1", "This message stays forever.", FlashMessageType.always);
@:flashMessage("message2", "This message dissappers after 10 seconds.", FlashMessageType.always, 10000);
@:flashMessage("message3", "This message is gone after your next refresh.", FlashMessageType.showOnce);
@:flashMessage("message4", "This message is gone after your next refresh and shows for 20 seconds.", FlashMessageType.showOnce, 20000);
</pre>
;

FEATURES_AUTO_MAPPING_CONTENT:
Controller actions are auto-mapped by their function definitions that are declared with special attributes.
<pre>
/// Route: /controller_or_view_route/GetSomething
@HttpAction(HttpGet) Status getSomething()
{
    auto someModel = getSomeModel();

    return json(someModel);
}
</pre>
;

FEATURES_VIEW_INTEGRATION_CONTENT:
Controllers have access directly to the view that’s calling them. They can be shared between multiple views too.
<pre>
@HttpDefault defaultAction()
{
    view.model = getViewModel();

    return Status.success;
}
</pre>
;

FEATURES_MANDATORY_ACTIONS_CONTENT:
Controllers allows for mandatory actions, which are actions that are executed and must succeed on every request done to a controller.
<pre>
/// Called for all requests done to the controller.
@HttpMandatory Status isValidRequest()
{
    auto isValid = validateRequest(view.client);

    if (!isValid)
    {
        view.client.error(HttpStatus.badRequest);
    }

    return Status.success;
}
</pre>
;

FEATURES_VERSION_CONTROL_CONTENT:
When building web-applications and building a new version you might want to versionate the project, allowing for both an old and a new api to be used.
<br><br>
This is useful when you’re trying to migrate an application from an old api to a new api, when the new api hasn’t yet implemented all the features the old api has.
<br><br>
<b>Old home controller:</b>
<pre>
@HttpVersion("v2", NewHomeController.stringof) final class OldHomeController(TView) : Controller!TView
{
  public:
  final:
  /**
  * Creates a new instance of the old home controller.
  * Params:
  *   view =  The view assocaited with the controller.
  */
  this(TView view)
  {
    super(view);
  }

  /// Route: / | /home
  @HttpDefault Status home()
  {
    return Status.success;
  }

  /// Route: /home/getValue
  @HttpAction(HttpGet) Status getValue()
  {
      return jsonString(`{
          "success": true,
          "message": "Old"
      }`);
  }
}
</pre>
<br>
<b>New home controller:</b>
<pre>
final class NewHomeController(TView) : Controller!TView
{
  public:
  final:
  /**
  * Creates a new instance of the new controller.
  * Params:
  *   view =  The view assocaited with the controller.
  */
  this(TView view)
  {
    super(view);
  }

  /// Route: /home/v2
  @HttpDefault Status home()
  {
    return Status.success;
  }

  /// Route: /home/v2/getValue
  @HttpAction(HttpGet) Status getValue()
  {
      return jsonString(`{
          "success": true,
          "message": "New"
      }`);
  }
}
</pre>
;

FEATURES_AUTHENTICATION_CONTENT:
Diamond has a full integrated authentication API that can be combined with the ACL to create a strong and secure authentication implementation.
<br><br>
<b>Login:</b>
<pre>
long loginTimeInMinutes = 99999;
auto userRole = getRole("user");

client.login(loginTimeinMinutes, userRole);
</pre>
<br>
<b>Logout:</b>
<pre>
client.logout();
</pre>
<br>
<b>Checking Role:</b>
<pre>
if (client.role.name == "user")
{
    // Logged in as a user ...
}
else
{
    // Not logged in as a user ...
}
</pre>
;

FEATURES_CSRF_PROTECTION_CONTENT:
CSRF Protection is build-in to Diamond and can easily be integrated to forms, as well validated in an application’s backend.
<br><br>
<b>View:</b>
<pre>
@:clearCSRFToken();

&lt;form&gt;
@:appendCSRFTokenField("formToken");

@* other fields here *
&lt;/form&gt;
</pre>
<br>
<b>Controller:</b>
<pre>
auto bankTransferModel = view.client.getModelFromJson!BankTransferModel;

import diamond.security;

if (!isValidCSRFToken(view.client, bankTransferModel.formToken, true))
{
    view.client.error(HttpStatus.badRequest);
}
</pre>
;

FEATURES_CRYPTOGRAPHY_CONTENT:
Cryptography is supported through the vibe.d’s dependency to Botan.
<br><br>
See: <a href="https://code.dlang.org/packages/botan/">https://code.dlang.org/packages/botan/</a>
;

FEATURES_JSON_BSON_CONTENT:
JSON & BSON is supported through the vibe.d integration, but some high-level json support is done to integrate better with it.
<pre>
auto model = client.getModelFromJson!MyModel;
</pre>

<pre>
@HttpAction(HttpGet) Status getModel()
{
     return json(getMyModel());
}
</pre>

<pre>
@HttpAction(HttpGet) Status getRawJsonString()
{
    return jsonString(q{{
        "message": "Hello World!",
        "success": true
    }});
}
</pre>
;

FEATURES_ASYNC_CONTENT:
Diamond requests are processed asynchrnously through vibe.d,
making request processing fast and powerful.
<br><br>
Actions etc. can also be executed asynchronously using the API provided by vibe.d.
<br>
<img src="http://vibed.org/images/feature_event.png">
<br>
Source: <a href="http://vibed.org/features">http://vibed.org/features</a>
;

FEATURES_FIBERS_TASKS_CONTENT:
Fibers and tasks are supported through vibe.d allowing for very powerful and performant multi-threading.
<br>
<img src="http://vibed.org/images/feature_fibers.png">
<br>
Source: <a href="http://vibed.org/features">http://vibed.org/features</a>
;

FEATURES_SHARDING_CONTENT:
Diamond supports multiple database systems such as MySql, Mongo and Redis and integration with them can be done easily without any complexity put into code.
;

FEATURES_NETWORK_SECURITY_CONTENT:
Network security and restrictions can easily be done per controller actions/route or globally for the whole application.
<br><br>
This allows to restrict certain areas of the application to ex. a local network; very useful for intern administration websites that are hosted on the same server as a public website.
;

FEATURES_UNITTESTING_CONTENT:
Unittesting is a must for enterprise development and must be implemented for an application to make sure everything works how it’s supposed to be.
<br><br>
Unittesting in Diamond will allow for you to create specialized requests that can target certain areas of your application.
<pre>
module unittests.test;

import diamond.unittesting;

static if (isTesting)
{
  class JsonResponse
  {
    string message;
    bool success;
  }

  @HttpTest("My first unittest") test()
  {
    testRequest("/home/test/100", HttpMethod.GET, (scope result)
    {
      assert(result.statusCode == HttpStatus.ok);

      auto foo = result.getModelFromJson!JsonResponse;

      assert(foo.success);
    });

    testRequest("/home/test/500", HttpMethod.GET, (scope result)
    {
      assert(result.statusCode == HttpStatus.ok);

      auto foo = result.getModelFromJson!JsonResponse;

      assert(!foo.success);
    });
  }
}
</pre>
;

FEATURES_LOGGING_CONTENT:
Logging is useful to log information about requests, responses, errors etc. It’s an essential tool for debugging enterprise applications.
<br><br>
<pre>
log(LogType.error, (result)
{
    logToMSSQLDatabase(result); // Custom implementation to log to a MSSQL database.
});
</pre>

<pre>
logToFile(LogType.error, "errors.log");

...

logToFile(LogType.error, "errors.log",
(result)
{
    import diamond.core.io;
    print(result.toString()); // Prints the log out to the console as well ...
});
</pre>

<pre>
logToDatabase(LogType.error, "logs");

...

logToDatabase(LogType.error, "logs",
(result)
{
     import diamond.core.io;

     print("Logged '%s' to the database.", result.logToken);
});
</pre>
;
